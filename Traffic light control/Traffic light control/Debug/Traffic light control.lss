
Traffic light control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000dec  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000e60  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800060  00800060  00000e60  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e60  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000e90  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000110  00000000  00000000  00000ecc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001aa3  00000000  00000000  00000fdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000809  00000000  00000000  00002a7f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b69  00000000  00000000  00003288  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001ec  00000000  00000000  00003df4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000047f  00000000  00000000  00003fe0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a4d  00000000  00000000  0000445f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00004eac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 45 01 	jmp	0x28a	; 0x28a <__vector_1>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a3 36       	cpi	r26, 0x63	; 99
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 6d 03 	call	0x6da	; 0x6da <main>
  74:	0c 94 f4 06 	jmp	0xde8	; 0xde8 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <app_init>:
int Car_Led = 0; //GREEN --> 1 , yellow --> 2 ,RED--> 3

void app_init(void)
{
	//Car LED initialization
	LED_init(PORT_A,PIN0);
  7c:	60 e0       	ldi	r22, 0x00	; 0
  7e:	81 e4       	ldi	r24, 0x41	; 65
  80:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
	LED_init(PORT_A,PIN1);
  84:	61 e0       	ldi	r22, 0x01	; 1
  86:	81 e4       	ldi	r24, 0x41	; 65
  88:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
	LED_init(PORT_A,PIN2);
  8c:	62 e0       	ldi	r22, 0x02	; 2
  8e:	81 e4       	ldi	r24, 0x41	; 65
  90:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
	
	//Pedestrian LED initialization
	LED_init(PORT_B,PIN0);
  94:	60 e0       	ldi	r22, 0x00	; 0
  96:	82 e4       	ldi	r24, 0x42	; 66
  98:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
	LED_init(PORT_B,PIN1);
  9c:	61 e0       	ldi	r22, 0x01	; 1
  9e:	82 e4       	ldi	r24, 0x42	; 66
  a0:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
	LED_init(PORT_B,PIN2);
  a4:	62 e0       	ldi	r22, 0x02	; 2
  a6:	82 e4       	ldi	r24, 0x42	; 66
  a8:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
	
	//Button initialization
	BUTTON_init(BUTTON_1_PORT,BUTTON_1_PIN);
  ac:	62 e0       	ldi	r22, 0x02	; 2
  ae:	84 e4       	ldi	r24, 0x44	; 68
  b0:	0e 94 ed 02 	call	0x5da	; 0x5da <BUTTON_init>

	//Timer initialization
	Timer_init();
  b4:	0e 94 15 03 	call	0x62a	; 0x62a <Timer_init>
	

	//Enable Global interrupts & setup rising edge detection for button
	sei();
  b8:	78 94       	sei
	Rising_Edge_Setup();
  ba:	85 b7       	in	r24, 0x35	; 53
  bc:	83 60       	ori	r24, 0x03	; 3
  be:	85 bf       	out	0x35, r24	; 53
	Setup_INT0();
  c0:	8b b7       	in	r24, 0x3b	; 59
  c2:	80 64       	ori	r24, 0x40	; 64
  c4:	8b bf       	out	0x3b, r24	; 59
  c6:	08 95       	ret

000000c8 <app_start>:
};

void app_start(void)
{
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
		BUTTON_read(BUTTON_1_PORT,BUTTON_1_PIN,&buttonstate);
  cc:	42 e6       	ldi	r20, 0x62	; 98
  ce:	50 e0       	ldi	r21, 0x00	; 0
  d0:	62 e0       	ldi	r22, 0x02	; 2
  d2:	84 e4       	ldi	r24, 0x44	; 68
  d4:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <BUTTON_read>
		
		//Green
		LED_on(PORT_A,PIN0);
  d8:	60 e0       	ldi	r22, 0x00	; 0
  da:	81 e4       	ldi	r24, 0x41	; 65
  dc:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
		Car_Led = 1;
  e0:	81 e0       	ldi	r24, 0x01	; 1
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
  e8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		_delay_ms(5000);
  ec:	88 e8       	ldi	r24, 0x88	; 136
  ee:	93 e1       	ldi	r25, 0x13	; 19
  f0:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_off(PORT_A,PIN0);
  f4:	60 e0       	ldi	r22, 0x00	; 0
  f6:	81 e4       	ldi	r24, 0x41	; 65
  f8:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
		
		//Yellow blink
		LED_toggle(PORT_A,PIN1);
  fc:	61 e0       	ldi	r22, 0x01	; 1
  fe:	81 e4       	ldi	r24, 0x41	; 65
 100:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		Car_Led = 2;
 104:	c2 e0       	ldi	r28, 0x02	; 2
 106:	d0 e0       	ldi	r29, 0x00	; 0
 108:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 10c:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
		_delay_ms(500);
 110:	84 ef       	ldi	r24, 0xF4	; 244
 112:	91 e0       	ldi	r25, 0x01	; 1
 114:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 118:	61 e0       	ldi	r22, 0x01	; 1
 11a:	81 e4       	ldi	r24, 0x41	; 65
 11c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 120:	84 ef       	ldi	r24, 0xF4	; 244
 122:	91 e0       	ldi	r25, 0x01	; 1
 124:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 128:	61 e0       	ldi	r22, 0x01	; 1
 12a:	81 e4       	ldi	r24, 0x41	; 65
 12c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 130:	84 ef       	ldi	r24, 0xF4	; 244
 132:	91 e0       	ldi	r25, 0x01	; 1
 134:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 138:	61 e0       	ldi	r22, 0x01	; 1
 13a:	81 e4       	ldi	r24, 0x41	; 65
 13c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 140:	84 ef       	ldi	r24, 0xF4	; 244
 142:	91 e0       	ldi	r25, 0x01	; 1
 144:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 148:	61 e0       	ldi	r22, 0x01	; 1
 14a:	81 e4       	ldi	r24, 0x41	; 65
 14c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 150:	84 ef       	ldi	r24, 0xF4	; 244
 152:	91 e0       	ldi	r25, 0x01	; 1
 154:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 158:	61 e0       	ldi	r22, 0x01	; 1
 15a:	81 e4       	ldi	r24, 0x41	; 65
 15c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 160:	84 ef       	ldi	r24, 0xF4	; 244
 162:	91 e0       	ldi	r25, 0x01	; 1
 164:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 168:	61 e0       	ldi	r22, 0x01	; 1
 16a:	81 e4       	ldi	r24, 0x41	; 65
 16c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 170:	84 ef       	ldi	r24, 0xF4	; 244
 172:	91 e0       	ldi	r25, 0x01	; 1
 174:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 178:	61 e0       	ldi	r22, 0x01	; 1
 17a:	81 e4       	ldi	r24, 0x41	; 65
 17c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 180:	84 ef       	ldi	r24, 0xF4	; 244
 182:	91 e0       	ldi	r25, 0x01	; 1
 184:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 188:	61 e0       	ldi	r22, 0x01	; 1
 18a:	81 e4       	ldi	r24, 0x41	; 65
 18c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 190:	84 ef       	ldi	r24, 0xF4	; 244
 192:	91 e0       	ldi	r25, 0x01	; 1
 194:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 198:	61 e0       	ldi	r22, 0x01	; 1
 19a:	81 e4       	ldi	r24, 0x41	; 65
 19c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 1a0:	84 ef       	ldi	r24, 0xF4	; 244
 1a2:	91 e0       	ldi	r25, 0x01	; 1
 1a4:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_off(PORT_A,PIN1);
 1a8:	61 e0       	ldi	r22, 0x01	; 1
 1aa:	81 e4       	ldi	r24, 0x41	; 65
 1ac:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
	
		//Red led
		LED_on(PORT_A,PIN2);
 1b0:	62 e0       	ldi	r22, 0x02	; 2
 1b2:	81 e4       	ldi	r24, 0x41	; 65
 1b4:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
		Car_Led = 3;
 1b8:	83 e0       	ldi	r24, 0x03	; 3
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1c0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		_delay_ms(5000);
 1c4:	88 e8       	ldi	r24, 0x88	; 136
 1c6:	93 e1       	ldi	r25, 0x13	; 19
 1c8:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_off(PORT_A,PIN2);
 1cc:	62 e0       	ldi	r22, 0x02	; 2
 1ce:	81 e4       	ldi	r24, 0x41	; 65
 1d0:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
		
		//Yellow blink
		LED_toggle(PORT_A,PIN1);
 1d4:	61 e0       	ldi	r22, 0x01	; 1
 1d6:	81 e4       	ldi	r24, 0x41	; 65
 1d8:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		Car_Led = 2;
 1dc:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1e0:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
		_delay_ms(500);
 1e4:	84 ef       	ldi	r24, 0xF4	; 244
 1e6:	91 e0       	ldi	r25, 0x01	; 1
 1e8:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 1ec:	61 e0       	ldi	r22, 0x01	; 1
 1ee:	81 e4       	ldi	r24, 0x41	; 65
 1f0:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 1f4:	84 ef       	ldi	r24, 0xF4	; 244
 1f6:	91 e0       	ldi	r25, 0x01	; 1
 1f8:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 1fc:	61 e0       	ldi	r22, 0x01	; 1
 1fe:	81 e4       	ldi	r24, 0x41	; 65
 200:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 204:	84 ef       	ldi	r24, 0xF4	; 244
 206:	91 e0       	ldi	r25, 0x01	; 1
 208:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 20c:	61 e0       	ldi	r22, 0x01	; 1
 20e:	81 e4       	ldi	r24, 0x41	; 65
 210:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 214:	84 ef       	ldi	r24, 0xF4	; 244
 216:	91 e0       	ldi	r25, 0x01	; 1
 218:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 21c:	61 e0       	ldi	r22, 0x01	; 1
 21e:	81 e4       	ldi	r24, 0x41	; 65
 220:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 224:	84 ef       	ldi	r24, 0xF4	; 244
 226:	91 e0       	ldi	r25, 0x01	; 1
 228:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 22c:	61 e0       	ldi	r22, 0x01	; 1
 22e:	81 e4       	ldi	r24, 0x41	; 65
 230:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 234:	84 ef       	ldi	r24, 0xF4	; 244
 236:	91 e0       	ldi	r25, 0x01	; 1
 238:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 23c:	61 e0       	ldi	r22, 0x01	; 1
 23e:	81 e4       	ldi	r24, 0x41	; 65
 240:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 244:	84 ef       	ldi	r24, 0xF4	; 244
 246:	91 e0       	ldi	r25, 0x01	; 1
 248:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 24c:	61 e0       	ldi	r22, 0x01	; 1
 24e:	81 e4       	ldi	r24, 0x41	; 65
 250:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 254:	84 ef       	ldi	r24, 0xF4	; 244
 256:	91 e0       	ldi	r25, 0x01	; 1
 258:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 25c:	61 e0       	ldi	r22, 0x01	; 1
 25e:	81 e4       	ldi	r24, 0x41	; 65
 260:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 264:	84 ef       	ldi	r24, 0xF4	; 244
 266:	91 e0       	ldi	r25, 0x01	; 1
 268:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_toggle(PORT_A,PIN1);
 26c:	61 e0       	ldi	r22, 0x01	; 1
 26e:	81 e4       	ldi	r24, 0x41	; 65
 270:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
		_delay_ms(500);
 274:	84 ef       	ldi	r24, 0xF4	; 244
 276:	91 e0       	ldi	r25, 0x01	; 1
 278:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		LED_off(PORT_A,PIN1);
 27c:	61 e0       	ldi	r22, 0x01	; 1
 27e:	81 e4       	ldi	r24, 0x41	; 65
 280:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
}
 284:	df 91       	pop	r29
 286:	cf 91       	pop	r28
 288:	08 95       	ret

0000028a <__vector_1>:

ISR(EXT_INT_0)
{
 28a:	1f 92       	push	r1
 28c:	0f 92       	push	r0
 28e:	0f b6       	in	r0, 0x3f	; 63
 290:	0f 92       	push	r0
 292:	11 24       	eor	r1, r1
 294:	2f 93       	push	r18
 296:	3f 93       	push	r19
 298:	4f 93       	push	r20
 29a:	5f 93       	push	r21
 29c:	6f 93       	push	r22
 29e:	7f 93       	push	r23
 2a0:	8f 93       	push	r24
 2a2:	9f 93       	push	r25
 2a4:	af 93       	push	r26
 2a6:	bf 93       	push	r27
 2a8:	ef 93       	push	r30
 2aa:	ff 93       	push	r31
	BUTTON_read(BUTTON_1_PORT,BUTTON_1_PIN,&buttonstate);
 2ac:	42 e6       	ldi	r20, 0x62	; 98
 2ae:	50 e0       	ldi	r21, 0x00	; 0
 2b0:	62 e0       	ldi	r22, 0x02	; 2
 2b2:	84 e4       	ldi	r24, 0x44	; 68
 2b4:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <BUTTON_read>
	if( buttonstate == HIGH )
 2b8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <buttonstate>
 2bc:	81 30       	cpi	r24, 0x01	; 1
 2be:	09 f0       	breq	.+2      	; 0x2c2 <__vector_1+0x38>
 2c0:	7b c1       	rjmp	.+758    	; 0x5b8 <__EEPROM_REGION_LENGTH__+0x1b8>
	{
		_delay_ms(1000);
 2c2:	88 ee       	ldi	r24, 0xE8	; 232
 2c4:	93 e0       	ldi	r25, 0x03	; 3
 2c6:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
		BUTTON_read(BUTTON_1_PORT,BUTTON_1_PIN,&buttonstate);
 2ca:	42 e6       	ldi	r20, 0x62	; 98
 2cc:	50 e0       	ldi	r21, 0x00	; 0
 2ce:	62 e0       	ldi	r22, 0x02	; 2
 2d0:	84 e4       	ldi	r24, 0x44	; 68
 2d2:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <BUTTON_read>
		if( buttonstate != HIGH )
 2d6:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <buttonstate>
 2da:	81 30       	cpi	r24, 0x01	; 1
 2dc:	09 f4       	brne	.+2      	; 0x2e0 <__vector_1+0x56>
 2de:	6c c1       	rjmp	.+728    	; 0x5b8 <__EEPROM_REGION_LENGTH__+0x1b8>
		{
			switch(Car_Led)
 2e0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 2e4:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 2e8:	82 30       	cpi	r24, 0x02	; 2
 2ea:	91 05       	cpc	r25, r1
 2ec:	09 f4       	brne	.+2      	; 0x2f0 <__vector_1+0x66>
 2ee:	ac c0       	rjmp	.+344    	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
 2f0:	83 30       	cpi	r24, 0x03	; 3
 2f2:	91 05       	cpc	r25, r1
 2f4:	09 f4       	brne	.+2      	; 0x2f8 <__vector_1+0x6e>
 2f6:	48 c1       	rjmp	.+656    	; 0x588 <__EEPROM_REGION_LENGTH__+0x188>
 2f8:	01 97       	sbiw	r24, 0x01	; 1
 2fa:	09 f0       	breq	.+2      	; 0x2fe <__vector_1+0x74>
 2fc:	5d c1       	rjmp	.+698    	; 0x5b8 <__EEPROM_REGION_LENGTH__+0x1b8>
				/***************************************/
				/******if the car led is yellow the pedestrian led will be yellow and there both yellow will blink for 5 sec**/
				/*****************then the car led will be red and the pedestrian led will be green for 5 sec ****************/

				case 1 :
				LED_on(PORT_B,PIN2);
 2fe:	62 e0       	ldi	r22, 0x02	; 2
 300:	82 e4       	ldi	r24, 0x42	; 66
 302:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				_delay_ms(5000);
 306:	88 e8       	ldi	r24, 0x88	; 136
 308:	93 e1       	ldi	r25, 0x13	; 19
 30a:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_off(PORT_A,PIN0);
 30e:	60 e0       	ldi	r22, 0x00	; 0
 310:	81 e4       	ldi	r24, 0x41	; 65
 312:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN2);
 316:	62 e0       	ldi	r22, 0x02	; 2
 318:	82 e4       	ldi	r24, 0x42	; 66
 31a:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_toggle(PORT_A,PIN1);
 31e:	61 e0       	ldi	r22, 0x01	; 1
 320:	81 e4       	ldi	r24, 0x41	; 65
 322:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 326:	61 e0       	ldi	r22, 0x01	; 1
 328:	82 e4       	ldi	r24, 0x42	; 66
 32a:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 32e:	84 ef       	ldi	r24, 0xF4	; 244
 330:	91 e0       	ldi	r25, 0x01	; 1
 332:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 336:	61 e0       	ldi	r22, 0x01	; 1
 338:	81 e4       	ldi	r24, 0x41	; 65
 33a:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 33e:	61 e0       	ldi	r22, 0x01	; 1
 340:	82 e4       	ldi	r24, 0x42	; 66
 342:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 346:	84 ef       	ldi	r24, 0xF4	; 244
 348:	91 e0       	ldi	r25, 0x01	; 1
 34a:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 34e:	61 e0       	ldi	r22, 0x01	; 1
 350:	81 e4       	ldi	r24, 0x41	; 65
 352:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 356:	61 e0       	ldi	r22, 0x01	; 1
 358:	82 e4       	ldi	r24, 0x42	; 66
 35a:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 35e:	84 ef       	ldi	r24, 0xF4	; 244
 360:	91 e0       	ldi	r25, 0x01	; 1
 362:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 366:	61 e0       	ldi	r22, 0x01	; 1
 368:	81 e4       	ldi	r24, 0x41	; 65
 36a:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 36e:	61 e0       	ldi	r22, 0x01	; 1
 370:	82 e4       	ldi	r24, 0x42	; 66
 372:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 376:	84 ef       	ldi	r24, 0xF4	; 244
 378:	91 e0       	ldi	r25, 0x01	; 1
 37a:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 37e:	61 e0       	ldi	r22, 0x01	; 1
 380:	81 e4       	ldi	r24, 0x41	; 65
 382:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 386:	61 e0       	ldi	r22, 0x01	; 1
 388:	82 e4       	ldi	r24, 0x42	; 66
 38a:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 38e:	84 ef       	ldi	r24, 0xF4	; 244
 390:	91 e0       	ldi	r25, 0x01	; 1
 392:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 396:	61 e0       	ldi	r22, 0x01	; 1
 398:	81 e4       	ldi	r24, 0x41	; 65
 39a:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 39e:	61 e0       	ldi	r22, 0x01	; 1
 3a0:	82 e4       	ldi	r24, 0x42	; 66
 3a2:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 3a6:	84 ef       	ldi	r24, 0xF4	; 244
 3a8:	91 e0       	ldi	r25, 0x01	; 1
 3aa:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 3ae:	61 e0       	ldi	r22, 0x01	; 1
 3b0:	81 e4       	ldi	r24, 0x41	; 65
 3b2:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 3b6:	61 e0       	ldi	r22, 0x01	; 1
 3b8:	82 e4       	ldi	r24, 0x42	; 66
 3ba:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 3be:	84 ef       	ldi	r24, 0xF4	; 244
 3c0:	91 e0       	ldi	r25, 0x01	; 1
 3c2:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 3c6:	61 e0       	ldi	r22, 0x01	; 1
 3c8:	81 e4       	ldi	r24, 0x41	; 65
 3ca:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 3ce:	61 e0       	ldi	r22, 0x01	; 1
 3d0:	82 e4       	ldi	r24, 0x42	; 66
 3d2:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 3d6:	84 ef       	ldi	r24, 0xF4	; 244
 3d8:	91 e0       	ldi	r25, 0x01	; 1
 3da:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 3de:	61 e0       	ldi	r22, 0x01	; 1
 3e0:	81 e4       	ldi	r24, 0x41	; 65
 3e2:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 3e6:	61 e0       	ldi	r22, 0x01	; 1
 3e8:	82 e4       	ldi	r24, 0x42	; 66
 3ea:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 3ee:	84 ef       	ldi	r24, 0xF4	; 244
 3f0:	91 e0       	ldi	r25, 0x01	; 1
 3f2:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 3f6:	61 e0       	ldi	r22, 0x01	; 1
 3f8:	81 e4       	ldi	r24, 0x41	; 65
 3fa:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 3fe:	61 e0       	ldi	r22, 0x01	; 1
 400:	82 e4       	ldi	r24, 0x42	; 66
 402:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 406:	84 ef       	ldi	r24, 0xF4	; 244
 408:	91 e0       	ldi	r25, 0x01	; 1
 40a:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_off(PORT_A,PIN1);
 40e:	61 e0       	ldi	r22, 0x01	; 1
 410:	81 e4       	ldi	r24, 0x41	; 65
 412:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN1);
 416:	61 e0       	ldi	r22, 0x01	; 1
 418:	82 e4       	ldi	r24, 0x42	; 66
 41a:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_on(PORT_B,PIN0);
 41e:	60 e0       	ldi	r22, 0x00	; 0
 420:	82 e4       	ldi	r24, 0x42	; 66
 422:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				LED_on(PORT_A,PIN2);
 426:	62 e0       	ldi	r22, 0x02	; 2
 428:	81 e4       	ldi	r24, 0x41	; 65
 42a:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				_delay_ms(5000);
 42e:	88 e8       	ldi	r24, 0x88	; 136
 430:	93 e1       	ldi	r25, 0x13	; 19
 432:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_off(PORT_A,PIN2);
 436:	62 e0       	ldi	r22, 0x02	; 2
 438:	81 e4       	ldi	r24, 0x41	; 65
 43a:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN0);
 43e:	60 e0       	ldi	r22, 0x00	; 0
 440:	82 e4       	ldi	r24, 0x42	; 66
 442:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				break;
 446:	b8 c0       	rjmp	.+368    	; 0x5b8 <__EEPROM_REGION_LENGTH__+0x1b8>
				
				case 2:
				LED_on(PORT_B,PIN2);
 448:	62 e0       	ldi	r22, 0x02	; 2
 44a:	82 e4       	ldi	r24, 0x42	; 66
 44c:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				LED_off(PORT_A,PIN0);
 450:	60 e0       	ldi	r22, 0x00	; 0
 452:	81 e4       	ldi	r24, 0x41	; 65
 454:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN2);
 458:	62 e0       	ldi	r22, 0x02	; 2
 45a:	82 e4       	ldi	r24, 0x42	; 66
 45c:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_toggle(PORT_A,PIN1);
 460:	61 e0       	ldi	r22, 0x01	; 1
 462:	81 e4       	ldi	r24, 0x41	; 65
 464:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 468:	61 e0       	ldi	r22, 0x01	; 1
 46a:	82 e4       	ldi	r24, 0x42	; 66
 46c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 470:	84 ef       	ldi	r24, 0xF4	; 244
 472:	91 e0       	ldi	r25, 0x01	; 1
 474:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 478:	61 e0       	ldi	r22, 0x01	; 1
 47a:	81 e4       	ldi	r24, 0x41	; 65
 47c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 480:	61 e0       	ldi	r22, 0x01	; 1
 482:	82 e4       	ldi	r24, 0x42	; 66
 484:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 488:	84 ef       	ldi	r24, 0xF4	; 244
 48a:	91 e0       	ldi	r25, 0x01	; 1
 48c:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 490:	61 e0       	ldi	r22, 0x01	; 1
 492:	81 e4       	ldi	r24, 0x41	; 65
 494:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 498:	61 e0       	ldi	r22, 0x01	; 1
 49a:	82 e4       	ldi	r24, 0x42	; 66
 49c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 4a0:	84 ef       	ldi	r24, 0xF4	; 244
 4a2:	91 e0       	ldi	r25, 0x01	; 1
 4a4:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 4a8:	61 e0       	ldi	r22, 0x01	; 1
 4aa:	81 e4       	ldi	r24, 0x41	; 65
 4ac:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 4b0:	61 e0       	ldi	r22, 0x01	; 1
 4b2:	82 e4       	ldi	r24, 0x42	; 66
 4b4:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 4b8:	84 ef       	ldi	r24, 0xF4	; 244
 4ba:	91 e0       	ldi	r25, 0x01	; 1
 4bc:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 4c0:	61 e0       	ldi	r22, 0x01	; 1
 4c2:	81 e4       	ldi	r24, 0x41	; 65
 4c4:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 4c8:	61 e0       	ldi	r22, 0x01	; 1
 4ca:	82 e4       	ldi	r24, 0x42	; 66
 4cc:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 4d0:	84 ef       	ldi	r24, 0xF4	; 244
 4d2:	91 e0       	ldi	r25, 0x01	; 1
 4d4:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 4d8:	61 e0       	ldi	r22, 0x01	; 1
 4da:	81 e4       	ldi	r24, 0x41	; 65
 4dc:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 4e0:	61 e0       	ldi	r22, 0x01	; 1
 4e2:	82 e4       	ldi	r24, 0x42	; 66
 4e4:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 4e8:	84 ef       	ldi	r24, 0xF4	; 244
 4ea:	91 e0       	ldi	r25, 0x01	; 1
 4ec:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 4f0:	61 e0       	ldi	r22, 0x01	; 1
 4f2:	81 e4       	ldi	r24, 0x41	; 65
 4f4:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 4f8:	61 e0       	ldi	r22, 0x01	; 1
 4fa:	82 e4       	ldi	r24, 0x42	; 66
 4fc:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 500:	84 ef       	ldi	r24, 0xF4	; 244
 502:	91 e0       	ldi	r25, 0x01	; 1
 504:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 508:	61 e0       	ldi	r22, 0x01	; 1
 50a:	81 e4       	ldi	r24, 0x41	; 65
 50c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 510:	61 e0       	ldi	r22, 0x01	; 1
 512:	82 e4       	ldi	r24, 0x42	; 66
 514:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 518:	84 ef       	ldi	r24, 0xF4	; 244
 51a:	91 e0       	ldi	r25, 0x01	; 1
 51c:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 520:	61 e0       	ldi	r22, 0x01	; 1
 522:	81 e4       	ldi	r24, 0x41	; 65
 524:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 528:	61 e0       	ldi	r22, 0x01	; 1
 52a:	82 e4       	ldi	r24, 0x42	; 66
 52c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 530:	84 ef       	ldi	r24, 0xF4	; 244
 532:	91 e0       	ldi	r25, 0x01	; 1
 534:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_toggle(PORT_A,PIN1);
 538:	61 e0       	ldi	r22, 0x01	; 1
 53a:	81 e4       	ldi	r24, 0x41	; 65
 53c:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				LED_toggle(PORT_B,PIN1);
 540:	61 e0       	ldi	r22, 0x01	; 1
 542:	82 e4       	ldi	r24, 0x42	; 66
 544:	0e 94 0f 03 	call	0x61e	; 0x61e <LED_toggle>
				_delay_ms(500);
 548:	84 ef       	ldi	r24, 0xF4	; 244
 54a:	91 e0       	ldi	r25, 0x01	; 1
 54c:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_off(PORT_A,PIN1);
 550:	61 e0       	ldi	r22, 0x01	; 1
 552:	81 e4       	ldi	r24, 0x41	; 65
 554:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN1);
 558:	61 e0       	ldi	r22, 0x01	; 1
 55a:	82 e4       	ldi	r24, 0x42	; 66
 55c:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_on(PORT_B,PIN0);
 560:	60 e0       	ldi	r22, 0x00	; 0
 562:	82 e4       	ldi	r24, 0x42	; 66
 564:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				LED_on(PORT_A,PIN2);
 568:	62 e0       	ldi	r22, 0x02	; 2
 56a:	81 e4       	ldi	r24, 0x41	; 65
 56c:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				_delay_ms(5000);
 570:	88 e8       	ldi	r24, 0x88	; 136
 572:	93 e1       	ldi	r25, 0x13	; 19
 574:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_off(PORT_A,PIN2);
 578:	62 e0       	ldi	r22, 0x02	; 2
 57a:	81 e4       	ldi	r24, 0x41	; 65
 57c:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN0);
 580:	60 e0       	ldi	r22, 0x00	; 0
 582:	82 e4       	ldi	r24, 0x42	; 66
 584:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>

				/*********************************************************************************/
				/*******if the car led is red the pedestrian led  will be green  for 5 sec *******/
				/*********************************************************************************/
				case  3 :
				LED_on(PORT_A,PIN2);
 588:	62 e0       	ldi	r22, 0x02	; 2
 58a:	81 e4       	ldi	r24, 0x41	; 65
 58c:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				LED_on(PORT_B,PIN0);
 590:	60 e0       	ldi	r22, 0x00	; 0
 592:	82 e4       	ldi	r24, 0x42	; 66
 594:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				_delay_ms(5000);
 598:	88 e8       	ldi	r24, 0x88	; 136
 59a:	93 e1       	ldi	r25, 0x13	; 19
 59c:	0e 94 17 03 	call	0x62e	; 0x62e <_delay_ms>
				LED_off(PORT_A,PIN2);
 5a0:	62 e0       	ldi	r22, 0x02	; 2
 5a2:	81 e4       	ldi	r24, 0x41	; 65
 5a4:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_off(PORT_B,PIN0);
 5a8:	60 e0       	ldi	r22, 0x00	; 0
 5aa:	82 e4       	ldi	r24, 0x42	; 66
 5ac:	0e 94 08 03 	call	0x610	; 0x610 <LED_off>
				LED_on(PORT_A,PIN2);
 5b0:	62 e0       	ldi	r22, 0x02	; 2
 5b2:	81 e4       	ldi	r24, 0x41	; 65
 5b4:	0e 94 01 03 	call	0x602	; 0x602 <LED_on>
				break;
			}
		}
	}
 5b8:	ff 91       	pop	r31
 5ba:	ef 91       	pop	r30
 5bc:	bf 91       	pop	r27
 5be:	af 91       	pop	r26
 5c0:	9f 91       	pop	r25
 5c2:	8f 91       	pop	r24
 5c4:	7f 91       	pop	r23
 5c6:	6f 91       	pop	r22
 5c8:	5f 91       	pop	r21
 5ca:	4f 91       	pop	r20
 5cc:	3f 91       	pop	r19
 5ce:	2f 91       	pop	r18
 5d0:	0f 90       	pop	r0
 5d2:	0f be       	out	0x3f, r0	; 63
 5d4:	0f 90       	pop	r0
 5d6:	1f 90       	pop	r1
 5d8:	18 95       	reti

000005da <BUTTON_init>:
 *  Author: mahmo
 */ 
#include "button.h"

void BUTTON_init(uint8_t buttonPort, uint8_t buttonPin) //Button is an input device
{
 5da:	98 2f       	mov	r25, r24
 5dc:	86 2f       	mov	r24, r22
	DIO_init(buttonPin,buttonPort,IN);
 5de:	40 e0       	ldi	r20, 0x00	; 0
 5e0:	69 2f       	mov	r22, r25
 5e2:	0e 94 72 03 	call	0x6e4	; 0x6e4 <DIO_init>
 5e6:	08 95       	ret

000005e8 <BUTTON_read>:
}

void BUTTON_read(uint8_t buttonPort, uint8_t buttonPin, uint8_t *value)
{
 5e8:	98 2f       	mov	r25, r24
 5ea:	86 2f       	mov	r24, r22
	DIO_read(buttonPin, buttonPort, value);
 5ec:	69 2f       	mov	r22, r25
 5ee:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_read>
 5f2:	08 95       	ret

000005f4 <LED_init>:
 *  Author: mahmo
 */ 
#include "led.h"

void LED_init(uint8_t ledPort, uint8_t ledPin)
{
 5f4:	98 2f       	mov	r25, r24
 5f6:	86 2f       	mov	r24, r22
	DIO_init(ledPin,ledPort,OUT);
 5f8:	41 e0       	ldi	r20, 0x01	; 1
 5fa:	69 2f       	mov	r22, r25
 5fc:	0e 94 72 03 	call	0x6e4	; 0x6e4 <DIO_init>
 600:	08 95       	ret

00000602 <LED_on>:
};
void LED_on(uint8_t ledPort, uint8_t ledPin)
{
 602:	98 2f       	mov	r25, r24
 604:	86 2f       	mov	r24, r22
	DIO_write(ledPin,ledPort,HIGH);
 606:	41 e0       	ldi	r20, 0x01	; 1
 608:	69 2f       	mov	r22, r25
 60a:	0e 94 fd 03 	call	0x7fa	; 0x7fa <DIO_write>
 60e:	08 95       	ret

00000610 <LED_off>:
};
void LED_off(uint8_t ledPort, uint8_t ledPin)
{
 610:	98 2f       	mov	r25, r24
 612:	86 2f       	mov	r24, r22
	DIO_write(ledPin,ledPort,LOW);
 614:	40 e0       	ldi	r20, 0x00	; 0
 616:	69 2f       	mov	r22, r25
 618:	0e 94 fd 03 	call	0x7fa	; 0x7fa <DIO_write>
 61c:	08 95       	ret

0000061e <LED_toggle>:
}
void LED_toggle(uint8_t ledPort, uint8_t ledPin)
{
 61e:	98 2f       	mov	r25, r24
 620:	86 2f       	mov	r24, r22
	DIO_toggle(ledPin,ledPort);
 622:	69 2f       	mov	r22, r25
 624:	0e 94 88 04 	call	0x910	; 0x910 <DIO_toggle>
 628:	08 95       	ret

0000062a <Timer_init>:
#include <math.h>


void Timer_init()
{
	TCCR0 = 0x00; //normal mode
 62a:	13 be       	out	0x33, r1	; 51
 62c:	08 95       	ret

0000062e <_delay_ms>:
}
void _delay_ms(uint16_t ms){
 62e:	cf 92       	push	r12
 630:	df 92       	push	r13
 632:	ef 92       	push	r14
 634:	ff 92       	push	r15
 636:	cf 93       	push	r28
 638:	df 93       	push	r29
 63a:	ec 01       	movw	r28, r24
	//at 1MHz no prescaler
	// 256 prescaler
	Timertick = 256.0/1000.0; //ms    Timertick = prescaler/FCPU
	Timermaxdelay= 65.536; //ms		Timermaxdelay = Ttick * 2^8
	//if Timer_delay < Time_Maxdelay ,set initial timer value and wait for 1 overflow
	if(ms<Timermaxdelay)  
 63c:	bc 01       	movw	r22, r24
 63e:	80 e0       	ldi	r24, 0x00	; 0
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	0e 94 42 06 	call	0xc84	; 0xc84 <__floatunsisf>
 646:	6b 01       	movw	r12, r22
 648:	7c 01       	movw	r14, r24
 64a:	2f e6       	ldi	r18, 0x6F	; 111
 64c:	32 e1       	ldi	r19, 0x12	; 18
 64e:	43 e8       	ldi	r20, 0x83	; 131
 650:	52 e4       	ldi	r21, 0x42	; 66
 652:	0e 94 9c 05 	call	0xb38	; 0xb38 <__cmpsf2>
 656:	88 23       	and	r24, r24
 658:	8c f4       	brge	.+34     	; 0x67c <_delay_ms+0x4e>
	{
		TimerInitial = (Timermaxdelay-ms)/Timertick;
 65a:	a7 01       	movw	r20, r14
 65c:	96 01       	movw	r18, r12
 65e:	6f e6       	ldi	r22, 0x6F	; 111
 660:	72 e1       	ldi	r23, 0x12	; 18
 662:	83 e8       	ldi	r24, 0x83	; 131
 664:	92 e4       	ldi	r25, 0x42	; 66
 666:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__subsf3>
 66a:	2f e6       	ldi	r18, 0x6F	; 111
 66c:	32 e1       	ldi	r19, 0x12	; 18
 66e:	43 e8       	ldi	r20, 0x83	; 131
 670:	5e e3       	ldi	r21, 0x3E	; 62
 672:	0e 94 a1 05 	call	0xb42	; 0xb42 <__divsf3>
 676:	0e 94 13 06 	call	0xc26	; 0xc26 <__fixunssfsi>
 67a:	17 c0       	rjmp	.+46     	; 0x6aa <_delay_ms+0x7c>
		Noverflows = 1;
	}
	//if Timer_delay == Time_Maxdelay ,set initial timer value 0 and wait for 1 overflow
	else if(ms == (int)Timermaxdelay)  
 67c:	c1 34       	cpi	r28, 0x41	; 65
 67e:	d1 05       	cpc	r29, r1
 680:	99 f0       	breq	.+38     	; 0x6a8 <_delay_ms+0x7a>
	}
	//calculate the number of needed overflows and calculate the set timer initial value
	else
	{	
		Noverflows = ceil((double)Timertick/Timermaxdelay);
		TimerInitial = (1<<8) - ((double)ms/Timertick)/Noverflows;	
 682:	2f e6       	ldi	r18, 0x6F	; 111
 684:	32 e1       	ldi	r19, 0x12	; 18
 686:	43 e8       	ldi	r20, 0x83	; 131
 688:	5e e3       	ldi	r21, 0x3E	; 62
 68a:	c7 01       	movw	r24, r14
 68c:	b6 01       	movw	r22, r12
 68e:	0e 94 a1 05 	call	0xb42	; 0xb42 <__divsf3>
 692:	9b 01       	movw	r18, r22
 694:	ac 01       	movw	r20, r24
 696:	60 e0       	ldi	r22, 0x00	; 0
 698:	70 e0       	ldi	r23, 0x00	; 0
 69a:	80 e8       	ldi	r24, 0x80	; 128
 69c:	93 e4       	ldi	r25, 0x43	; 67
 69e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__subsf3>
 6a2:	0e 94 13 06 	call	0xc26	; 0xc26 <__fixunssfsi>
 6a6:	01 c0       	rjmp	.+2      	; 0x6aa <_delay_ms+0x7c>
		Noverflows = 1;
	}
	//if Timer_delay == Time_Maxdelay ,set initial timer value 0 and wait for 1 overflow
	else if(ms == (int)Timermaxdelay)  
	{
	TimerInitial=0;
 6a8:	60 e0       	ldi	r22, 0x00	; 0
	else
	{	
		Noverflows = ceil((double)Timertick/Timermaxdelay);
		TimerInitial = (1<<8) - ((double)ms/Timertick)/Noverflows;	
	}
	TCNT0 = TimerInitial;
 6aa:	62 bf       	out	0x32, r22	; 50
	TCCR0 |= (1<<2); //set 256 prescaler
 6ac:	83 b7       	in	r24, 0x33	; 51
 6ae:	84 60       	ori	r24, 0x04	; 4
 6b0:	83 bf       	out	0x33, r24	; 51
	TCCR0 = 0x00; //normal mode
}
void _delay_ms(uint16_t ms){
	uint16_t Noverflows,TimerInitial;
	double Timermaxdelay,Timertick;
	uint32_t overFlowcounter=0;
 6b2:	80 e0       	ldi	r24, 0x00	; 0
 6b4:	90 e0       	ldi	r25, 0x00	; 0
		Noverflows = ceil((double)Timertick/Timermaxdelay);
		TimerInitial = (1<<8) - ((double)ms/Timertick)/Noverflows;	
	}
	TCNT0 = TimerInitial;
	TCCR0 |= (1<<2); //set 256 prescaler
	while(overFlowcounter<Noverflows){
 6b6:	07 c0       	rjmp	.+14     	; 0x6c6 <_delay_ms+0x98>
		//busy wait
		while((TIFR & (1<<0))==0);
 6b8:	08 b6       	in	r0, 0x38	; 56
 6ba:	00 fe       	sbrs	r0, 0
 6bc:	fd cf       	rjmp	.-6      	; 0x6b8 <_delay_ms+0x8a>
		//clear overflow flag
		TIFR |=(1<<0);
 6be:	28 b7       	in	r18, 0x38	; 56
 6c0:	21 60       	ori	r18, 0x01	; 1
 6c2:	28 bf       	out	0x38, r18	; 56
		//increment counter
		overFlowcounter++;
 6c4:	01 96       	adiw	r24, 0x01	; 1
		Noverflows = ceil((double)Timertick/Timermaxdelay);
		TimerInitial = (1<<8) - ((double)ms/Timertick)/Noverflows;	
	}
	TCNT0 = TimerInitial;
	TCCR0 |= (1<<2); //set 256 prescaler
	while(overFlowcounter<Noverflows){
 6c6:	00 97       	sbiw	r24, 0x00	; 0
 6c8:	b9 f3       	breq	.-18     	; 0x6b8 <_delay_ms+0x8a>
		TIFR |=(1<<0);
		//increment counter
		overFlowcounter++;
	}
	//Timer stop
	TCCR0 = 0x00;
 6ca:	13 be       	out	0x33, r1	; 51
 6cc:	df 91       	pop	r29
 6ce:	cf 91       	pop	r28
 6d0:	ff 90       	pop	r15
 6d2:	ef 90       	pop	r14
 6d4:	df 90       	pop	r13
 6d6:	cf 90       	pop	r12
 6d8:	08 95       	ret

000006da <main>:


int main(void)
{
	//Initialize
	app_init();
 6da:	0e 94 3e 00 	call	0x7c	; 0x7c <app_init>
	
	//Main loop
	while(1){
		app_start();
 6de:	0e 94 64 00 	call	0xc8	; 0xc8 <app_start>
 6e2:	fd cf       	rjmp	.-6      	; 0x6de <main+0x4>

000006e4 <DIO_init>:

// global variables
// function definitions
void DIO_init(uint8_t pinNumber, uint8_t portNumber, uint8_t direction)
{
	switch(portNumber)
 6e4:	62 34       	cpi	r22, 0x42	; 66
 6e6:	59 f1       	breq	.+86     	; 0x73e <DIO_init+0x5a>
 6e8:	18 f4       	brcc	.+6      	; 0x6f0 <DIO_init+0xc>
 6ea:	61 34       	cpi	r22, 0x41	; 65
 6ec:	41 f0       	breq	.+16     	; 0x6fe <DIO_init+0x1a>
 6ee:	08 95       	ret
 6f0:	63 34       	cpi	r22, 0x43	; 67
 6f2:	09 f4       	brne	.+2      	; 0x6f6 <DIO_init+0x12>
 6f4:	44 c0       	rjmp	.+136    	; 0x77e <DIO_init+0x9a>
 6f6:	64 34       	cpi	r22, 0x44	; 68
 6f8:	09 f4       	brne	.+2      	; 0x6fc <DIO_init+0x18>
 6fa:	60 c0       	rjmp	.+192    	; 0x7bc <DIO_init+0xd8>
 6fc:	08 95       	ret
	{
		case PORT_A :
		if(direction == IN)  //Input
 6fe:	41 11       	cpse	r20, r1
 700:	0e c0       	rjmp	.+28     	; 0x71e <DIO_init+0x3a>
		{
			DDRA &= ~(1<<pinNumber);
 702:	4a b3       	in	r20, 0x1a	; 26
 704:	21 e0       	ldi	r18, 0x01	; 1
 706:	30 e0       	ldi	r19, 0x00	; 0
 708:	b9 01       	movw	r22, r18
 70a:	02 c0       	rjmp	.+4      	; 0x710 <DIO_init+0x2c>
 70c:	66 0f       	add	r22, r22
 70e:	77 1f       	adc	r23, r23
 710:	8a 95       	dec	r24
 712:	e2 f7       	brpl	.-8      	; 0x70c <DIO_init+0x28>
 714:	cb 01       	movw	r24, r22
 716:	80 95       	com	r24
 718:	84 23       	and	r24, r20
 71a:	8a bb       	out	0x1a, r24	; 26
 71c:	08 95       	ret
		}
		else if(direction == OUT)
 71e:	41 30       	cpi	r20, 0x01	; 1
 720:	09 f0       	breq	.+2      	; 0x724 <DIO_init+0x40>
 722:	6a c0       	rjmp	.+212    	; 0x7f8 <DIO_init+0x114>
		{
			DDRA |=(1<<pinNumber); //Output
 724:	4a b3       	in	r20, 0x1a	; 26
 726:	21 e0       	ldi	r18, 0x01	; 1
 728:	30 e0       	ldi	r19, 0x00	; 0
 72a:	b9 01       	movw	r22, r18
 72c:	02 c0       	rjmp	.+4      	; 0x732 <DIO_init+0x4e>
 72e:	66 0f       	add	r22, r22
 730:	77 1f       	adc	r23, r23
 732:	8a 95       	dec	r24
 734:	e2 f7       	brpl	.-8      	; 0x72e <DIO_init+0x4a>
 736:	cb 01       	movw	r24, r22
 738:	84 2b       	or	r24, r20
 73a:	8a bb       	out	0x1a, r24	; 26
 73c:	08 95       	ret
		{
			//Error handling
		}
		break;
		case PORT_B :
		if(direction == IN) //Input
 73e:	41 11       	cpse	r20, r1
 740:	0e c0       	rjmp	.+28     	; 0x75e <DIO_init+0x7a>
		{
			DDRB &= ~(1<<pinNumber);
 742:	47 b3       	in	r20, 0x17	; 23
 744:	21 e0       	ldi	r18, 0x01	; 1
 746:	30 e0       	ldi	r19, 0x00	; 0
 748:	b9 01       	movw	r22, r18
 74a:	02 c0       	rjmp	.+4      	; 0x750 <DIO_init+0x6c>
 74c:	66 0f       	add	r22, r22
 74e:	77 1f       	adc	r23, r23
 750:	8a 95       	dec	r24
 752:	e2 f7       	brpl	.-8      	; 0x74c <DIO_init+0x68>
 754:	cb 01       	movw	r24, r22
 756:	80 95       	com	r24
 758:	84 23       	and	r24, r20
 75a:	87 bb       	out	0x17, r24	; 23
 75c:	08 95       	ret
		}
		else if(direction == OUT)
 75e:	41 30       	cpi	r20, 0x01	; 1
 760:	09 f0       	breq	.+2      	; 0x764 <DIO_init+0x80>
 762:	4a c0       	rjmp	.+148    	; 0x7f8 <DIO_init+0x114>
		{
			DDRB |=(1<<pinNumber); //Output
 764:	47 b3       	in	r20, 0x17	; 23
 766:	21 e0       	ldi	r18, 0x01	; 1
 768:	30 e0       	ldi	r19, 0x00	; 0
 76a:	b9 01       	movw	r22, r18
 76c:	02 c0       	rjmp	.+4      	; 0x772 <DIO_init+0x8e>
 76e:	66 0f       	add	r22, r22
 770:	77 1f       	adc	r23, r23
 772:	8a 95       	dec	r24
 774:	e2 f7       	brpl	.-8      	; 0x76e <DIO_init+0x8a>
 776:	cb 01       	movw	r24, r22
 778:	84 2b       	or	r24, r20
 77a:	87 bb       	out	0x17, r24	; 23
 77c:	08 95       	ret
		{
			//Error handling
		}
		break;
		case PORT_C :
		if(direction == IN) //Input
 77e:	41 11       	cpse	r20, r1
 780:	0e c0       	rjmp	.+28     	; 0x79e <DIO_init+0xba>
		{
			DDRC &= ~(1<<pinNumber);
 782:	44 b3       	in	r20, 0x14	; 20
 784:	21 e0       	ldi	r18, 0x01	; 1
 786:	30 e0       	ldi	r19, 0x00	; 0
 788:	b9 01       	movw	r22, r18
 78a:	02 c0       	rjmp	.+4      	; 0x790 <DIO_init+0xac>
 78c:	66 0f       	add	r22, r22
 78e:	77 1f       	adc	r23, r23
 790:	8a 95       	dec	r24
 792:	e2 f7       	brpl	.-8      	; 0x78c <DIO_init+0xa8>
 794:	cb 01       	movw	r24, r22
 796:	80 95       	com	r24
 798:	84 23       	and	r24, r20
 79a:	84 bb       	out	0x14, r24	; 20
 79c:	08 95       	ret
		}
		else if(direction == OUT)
 79e:	41 30       	cpi	r20, 0x01	; 1
 7a0:	59 f5       	brne	.+86     	; 0x7f8 <DIO_init+0x114>
		{
			DDRC |=(1<<pinNumber); //Output
 7a2:	44 b3       	in	r20, 0x14	; 20
 7a4:	21 e0       	ldi	r18, 0x01	; 1
 7a6:	30 e0       	ldi	r19, 0x00	; 0
 7a8:	b9 01       	movw	r22, r18
 7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <DIO_init+0xcc>
 7ac:	66 0f       	add	r22, r22
 7ae:	77 1f       	adc	r23, r23
 7b0:	8a 95       	dec	r24
 7b2:	e2 f7       	brpl	.-8      	; 0x7ac <DIO_init+0xc8>
 7b4:	cb 01       	movw	r24, r22
 7b6:	84 2b       	or	r24, r20
 7b8:	84 bb       	out	0x14, r24	; 20
 7ba:	08 95       	ret
		{
			//Error handling
		}
		break;
		case PORT_D :
		if(direction == IN) //Input
 7bc:	41 11       	cpse	r20, r1
 7be:	0e c0       	rjmp	.+28     	; 0x7dc <DIO_init+0xf8>
		{
			DDRD &= ~(1<<pinNumber);
 7c0:	41 b3       	in	r20, 0x11	; 17
 7c2:	21 e0       	ldi	r18, 0x01	; 1
 7c4:	30 e0       	ldi	r19, 0x00	; 0
 7c6:	b9 01       	movw	r22, r18
 7c8:	02 c0       	rjmp	.+4      	; 0x7ce <DIO_init+0xea>
 7ca:	66 0f       	add	r22, r22
 7cc:	77 1f       	adc	r23, r23
 7ce:	8a 95       	dec	r24
 7d0:	e2 f7       	brpl	.-8      	; 0x7ca <DIO_init+0xe6>
 7d2:	cb 01       	movw	r24, r22
 7d4:	80 95       	com	r24
 7d6:	84 23       	and	r24, r20
 7d8:	81 bb       	out	0x11, r24	; 17
 7da:	08 95       	ret
		}
		else if(direction == OUT)
 7dc:	41 30       	cpi	r20, 0x01	; 1
 7de:	61 f4       	brne	.+24     	; 0x7f8 <DIO_init+0x114>
		{
			DDRD |=(1<<pinNumber); //Output
 7e0:	41 b3       	in	r20, 0x11	; 17
 7e2:	21 e0       	ldi	r18, 0x01	; 1
 7e4:	30 e0       	ldi	r19, 0x00	; 0
 7e6:	b9 01       	movw	r22, r18
 7e8:	02 c0       	rjmp	.+4      	; 0x7ee <DIO_init+0x10a>
 7ea:	66 0f       	add	r22, r22
 7ec:	77 1f       	adc	r23, r23
 7ee:	8a 95       	dec	r24
 7f0:	e2 f7       	brpl	.-8      	; 0x7ea <DIO_init+0x106>
 7f2:	cb 01       	movw	r24, r22
 7f4:	84 2b       	or	r24, r20
 7f6:	81 bb       	out	0x11, r24	; 17
 7f8:	08 95       	ret

000007fa <DIO_write>:
	}
};

void DIO_write(uint8_t pinNumber, uint8_t portNumber, uint8_t value)
{   
	  switch(portNumber)
 7fa:	62 34       	cpi	r22, 0x42	; 66
 7fc:	59 f1       	breq	.+86     	; 0x854 <__DATA_REGION_LENGTH__+0x54>
 7fe:	18 f4       	brcc	.+6      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
 800:	61 34       	cpi	r22, 0x41	; 65
 802:	41 f0       	breq	.+16     	; 0x814 <__DATA_REGION_LENGTH__+0x14>
 804:	08 95       	ret
 806:	63 34       	cpi	r22, 0x43	; 67
 808:	09 f4       	brne	.+2      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
 80a:	44 c0       	rjmp	.+136    	; 0x894 <__stack+0x35>
 80c:	64 34       	cpi	r22, 0x44	; 68
 80e:	09 f4       	brne	.+2      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
 810:	60 c0       	rjmp	.+192    	; 0x8d2 <__stack+0x73>
 812:	08 95       	ret
	   {
		case PORT_A :
		if(value == LOW) // Write 0 
 814:	41 11       	cpse	r20, r1
 816:	0e c0       	rjmp	.+28     	; 0x834 <__DATA_REGION_LENGTH__+0x34>
		{
			PORTA &= ~(1<<pinNumber);
 818:	4b b3       	in	r20, 0x1b	; 27
 81a:	21 e0       	ldi	r18, 0x01	; 1
 81c:	30 e0       	ldi	r19, 0x00	; 0
 81e:	b9 01       	movw	r22, r18
 820:	02 c0       	rjmp	.+4      	; 0x826 <__DATA_REGION_LENGTH__+0x26>
 822:	66 0f       	add	r22, r22
 824:	77 1f       	adc	r23, r23
 826:	8a 95       	dec	r24
 828:	e2 f7       	brpl	.-8      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
 82a:	cb 01       	movw	r24, r22
 82c:	80 95       	com	r24
 82e:	84 23       	and	r24, r20
 830:	8b bb       	out	0x1b, r24	; 27
 832:	08 95       	ret
		}
		else if(value == HIGH)
 834:	41 30       	cpi	r20, 0x01	; 1
 836:	09 f0       	breq	.+2      	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
 838:	6a c0       	rjmp	.+212    	; 0x90e <__stack+0xaf>
		{
			PORTA |=(1<<pinNumber); // Write 1 
 83a:	4b b3       	in	r20, 0x1b	; 27
 83c:	21 e0       	ldi	r18, 0x01	; 1
 83e:	30 e0       	ldi	r19, 0x00	; 0
 840:	b9 01       	movw	r22, r18
 842:	02 c0       	rjmp	.+4      	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 844:	66 0f       	add	r22, r22
 846:	77 1f       	adc	r23, r23
 848:	8a 95       	dec	r24
 84a:	e2 f7       	brpl	.-8      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
 84c:	cb 01       	movw	r24, r22
 84e:	84 2b       	or	r24, r20
 850:	8b bb       	out	0x1b, r24	; 27
 852:	08 95       	ret
		{
			//Error handling
		}
		break;
		case PORT_B :
		if(value == LOW) // Write 0 
 854:	41 11       	cpse	r20, r1
 856:	0e c0       	rjmp	.+28     	; 0x874 <__stack+0x15>
		{
			PORTB &= ~(1<<pinNumber);
 858:	48 b3       	in	r20, 0x18	; 24
 85a:	21 e0       	ldi	r18, 0x01	; 1
 85c:	30 e0       	ldi	r19, 0x00	; 0
 85e:	b9 01       	movw	r22, r18
 860:	02 c0       	rjmp	.+4      	; 0x866 <__stack+0x7>
 862:	66 0f       	add	r22, r22
 864:	77 1f       	adc	r23, r23
 866:	8a 95       	dec	r24
 868:	e2 f7       	brpl	.-8      	; 0x862 <__stack+0x3>
 86a:	cb 01       	movw	r24, r22
 86c:	80 95       	com	r24
 86e:	84 23       	and	r24, r20
 870:	88 bb       	out	0x18, r24	; 24
 872:	08 95       	ret
		}
		else if(value == HIGH)
 874:	41 30       	cpi	r20, 0x01	; 1
 876:	09 f0       	breq	.+2      	; 0x87a <__stack+0x1b>
 878:	4a c0       	rjmp	.+148    	; 0x90e <__stack+0xaf>
		{
			PORTB |= (1<<pinNumber); // Write 1 
 87a:	48 b3       	in	r20, 0x18	; 24
 87c:	21 e0       	ldi	r18, 0x01	; 1
 87e:	30 e0       	ldi	r19, 0x00	; 0
 880:	b9 01       	movw	r22, r18
 882:	02 c0       	rjmp	.+4      	; 0x888 <__stack+0x29>
 884:	66 0f       	add	r22, r22
 886:	77 1f       	adc	r23, r23
 888:	8a 95       	dec	r24
 88a:	e2 f7       	brpl	.-8      	; 0x884 <__stack+0x25>
 88c:	cb 01       	movw	r24, r22
 88e:	84 2b       	or	r24, r20
 890:	88 bb       	out	0x18, r24	; 24
 892:	08 95       	ret
		{
			//Error handling
		}
		break;
		case PORT_C :
		if(value == LOW) // Write 0 
 894:	41 11       	cpse	r20, r1
 896:	0e c0       	rjmp	.+28     	; 0x8b4 <__stack+0x55>
		{
			PORTC &= ~(1<<pinNumber);
 898:	45 b3       	in	r20, 0x15	; 21
 89a:	21 e0       	ldi	r18, 0x01	; 1
 89c:	30 e0       	ldi	r19, 0x00	; 0
 89e:	b9 01       	movw	r22, r18
 8a0:	02 c0       	rjmp	.+4      	; 0x8a6 <__stack+0x47>
 8a2:	66 0f       	add	r22, r22
 8a4:	77 1f       	adc	r23, r23
 8a6:	8a 95       	dec	r24
 8a8:	e2 f7       	brpl	.-8      	; 0x8a2 <__stack+0x43>
 8aa:	cb 01       	movw	r24, r22
 8ac:	80 95       	com	r24
 8ae:	84 23       	and	r24, r20
 8b0:	85 bb       	out	0x15, r24	; 21
 8b2:	08 95       	ret
		}
		else if(value == HIGH)
 8b4:	41 30       	cpi	r20, 0x01	; 1
 8b6:	59 f5       	brne	.+86     	; 0x90e <__stack+0xaf>
		{
			PORTC |= (1<<pinNumber); // Write 1 
 8b8:	45 b3       	in	r20, 0x15	; 21
 8ba:	21 e0       	ldi	r18, 0x01	; 1
 8bc:	30 e0       	ldi	r19, 0x00	; 0
 8be:	b9 01       	movw	r22, r18
 8c0:	02 c0       	rjmp	.+4      	; 0x8c6 <__stack+0x67>
 8c2:	66 0f       	add	r22, r22
 8c4:	77 1f       	adc	r23, r23
 8c6:	8a 95       	dec	r24
 8c8:	e2 f7       	brpl	.-8      	; 0x8c2 <__stack+0x63>
 8ca:	cb 01       	movw	r24, r22
 8cc:	84 2b       	or	r24, r20
 8ce:	85 bb       	out	0x15, r24	; 21
 8d0:	08 95       	ret
		{
			//Error handling
		}
		break;
		case PORT_D :
		if(value == LOW) // Write 0 
 8d2:	41 11       	cpse	r20, r1
 8d4:	0e c0       	rjmp	.+28     	; 0x8f2 <__stack+0x93>
		{
			PORTD &= ~(1<<pinNumber);
 8d6:	42 b3       	in	r20, 0x12	; 18
 8d8:	21 e0       	ldi	r18, 0x01	; 1
 8da:	30 e0       	ldi	r19, 0x00	; 0
 8dc:	b9 01       	movw	r22, r18
 8de:	02 c0       	rjmp	.+4      	; 0x8e4 <__stack+0x85>
 8e0:	66 0f       	add	r22, r22
 8e2:	77 1f       	adc	r23, r23
 8e4:	8a 95       	dec	r24
 8e6:	e2 f7       	brpl	.-8      	; 0x8e0 <__stack+0x81>
 8e8:	cb 01       	movw	r24, r22
 8ea:	80 95       	com	r24
 8ec:	84 23       	and	r24, r20
 8ee:	82 bb       	out	0x12, r24	; 18
 8f0:	08 95       	ret
		}
		else if(value == HIGH)
 8f2:	41 30       	cpi	r20, 0x01	; 1
 8f4:	61 f4       	brne	.+24     	; 0x90e <__stack+0xaf>
		{
			PORTD |= (1<<pinNumber); // Write 1 
 8f6:	42 b3       	in	r20, 0x12	; 18
 8f8:	21 e0       	ldi	r18, 0x01	; 1
 8fa:	30 e0       	ldi	r19, 0x00	; 0
 8fc:	b9 01       	movw	r22, r18
 8fe:	02 c0       	rjmp	.+4      	; 0x904 <__stack+0xa5>
 900:	66 0f       	add	r22, r22
 902:	77 1f       	adc	r23, r23
 904:	8a 95       	dec	r24
 906:	e2 f7       	brpl	.-8      	; 0x900 <__stack+0xa1>
 908:	cb 01       	movw	r24, r22
 90a:	84 2b       	or	r24, r20
 90c:	82 bb       	out	0x12, r24	; 18
 90e:	08 95       	ret

00000910 <DIO_toggle>:
		break;
	}
};
void DIO_toggle(uint8_t pinNumber, uint8_t portNumber)
{
	switch(portNumber)
 910:	62 34       	cpi	r22, 0x42	; 66
 912:	b1 f0       	breq	.+44     	; 0x940 <DIO_toggle+0x30>
 914:	18 f4       	brcc	.+6      	; 0x91c <DIO_toggle+0xc>
 916:	61 34       	cpi	r22, 0x41	; 65
 918:	31 f0       	breq	.+12     	; 0x926 <DIO_toggle+0x16>
 91a:	08 95       	ret
 91c:	63 34       	cpi	r22, 0x43	; 67
 91e:	e9 f0       	breq	.+58     	; 0x95a <DIO_toggle+0x4a>
 920:	64 34       	cpi	r22, 0x44	; 68
 922:	41 f1       	breq	.+80     	; 0x974 <DIO_toggle+0x64>
 924:	08 95       	ret
	{
		case PORT_A:
		PORTA ^=(1<<pinNumber); // change state -> toggle bit
 926:	4b b3       	in	r20, 0x1b	; 27
 928:	21 e0       	ldi	r18, 0x01	; 1
 92a:	30 e0       	ldi	r19, 0x00	; 0
 92c:	b9 01       	movw	r22, r18
 92e:	02 c0       	rjmp	.+4      	; 0x934 <DIO_toggle+0x24>
 930:	66 0f       	add	r22, r22
 932:	77 1f       	adc	r23, r23
 934:	8a 95       	dec	r24
 936:	e2 f7       	brpl	.-8      	; 0x930 <DIO_toggle+0x20>
 938:	cb 01       	movw	r24, r22
 93a:	84 27       	eor	r24, r20
 93c:	8b bb       	out	0x1b, r24	; 27
		break;
 93e:	08 95       	ret
		case PORT_B:
		PORTB ^=(1<<pinNumber); // change state -> toggle bit
 940:	48 b3       	in	r20, 0x18	; 24
 942:	21 e0       	ldi	r18, 0x01	; 1
 944:	30 e0       	ldi	r19, 0x00	; 0
 946:	b9 01       	movw	r22, r18
 948:	02 c0       	rjmp	.+4      	; 0x94e <DIO_toggle+0x3e>
 94a:	66 0f       	add	r22, r22
 94c:	77 1f       	adc	r23, r23
 94e:	8a 95       	dec	r24
 950:	e2 f7       	brpl	.-8      	; 0x94a <DIO_toggle+0x3a>
 952:	cb 01       	movw	r24, r22
 954:	84 27       	eor	r24, r20
 956:	88 bb       	out	0x18, r24	; 24
		break;
 958:	08 95       	ret
		case PORT_C:
		PORTC ^=(1<<pinNumber); // change state -> toggle bit
 95a:	45 b3       	in	r20, 0x15	; 21
 95c:	21 e0       	ldi	r18, 0x01	; 1
 95e:	30 e0       	ldi	r19, 0x00	; 0
 960:	b9 01       	movw	r22, r18
 962:	02 c0       	rjmp	.+4      	; 0x968 <DIO_toggle+0x58>
 964:	66 0f       	add	r22, r22
 966:	77 1f       	adc	r23, r23
 968:	8a 95       	dec	r24
 96a:	e2 f7       	brpl	.-8      	; 0x964 <DIO_toggle+0x54>
 96c:	cb 01       	movw	r24, r22
 96e:	84 27       	eor	r24, r20
 970:	85 bb       	out	0x15, r24	; 21
		break;
 972:	08 95       	ret
		case PORT_D:
		PORTD ^=(1<<pinNumber); // change state -> toggle bit
 974:	42 b3       	in	r20, 0x12	; 18
 976:	21 e0       	ldi	r18, 0x01	; 1
 978:	30 e0       	ldi	r19, 0x00	; 0
 97a:	b9 01       	movw	r22, r18
 97c:	02 c0       	rjmp	.+4      	; 0x982 <DIO_toggle+0x72>
 97e:	66 0f       	add	r22, r22
 980:	77 1f       	adc	r23, r23
 982:	8a 95       	dec	r24
 984:	e2 f7       	brpl	.-8      	; 0x97e <DIO_toggle+0x6e>
 986:	cb 01       	movw	r24, r22
 988:	84 27       	eor	r24, r20
 98a:	82 bb       	out	0x12, r24	; 18
 98c:	08 95       	ret

0000098e <DIO_read>:
	}
};

void DIO_read(uint8_t pinNumber, uint8_t portNumber, uint8_t *value)
{
	switch(portNumber)
 98e:	62 34       	cpi	r22, 0x42	; 66
 990:	09 f1       	breq	.+66     	; 0x9d4 <DIO_read+0x46>
 992:	18 f4       	brcc	.+6      	; 0x99a <DIO_read+0xc>
 994:	61 34       	cpi	r22, 0x41	; 65
 996:	39 f0       	breq	.+14     	; 0x9a6 <DIO_read+0x18>
 998:	08 95       	ret
 99a:	63 34       	cpi	r22, 0x43	; 67
 99c:	91 f1       	breq	.+100    	; 0xa02 <DIO_read+0x74>
 99e:	64 34       	cpi	r22, 0x44	; 68
 9a0:	09 f4       	brne	.+2      	; 0x9a4 <DIO_read+0x16>
 9a2:	46 c0       	rjmp	.+140    	; 0xa30 <DIO_read+0xa2>
 9a4:	08 95       	ret
	{
		case PORT_A:
		*value = (PINA & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 9a6:	99 b3       	in	r25, 0x19	; 25
 9a8:	21 e0       	ldi	r18, 0x01	; 1
 9aa:	30 e0       	ldi	r19, 0x00	; 0
 9ac:	b9 01       	movw	r22, r18
 9ae:	08 2e       	mov	r0, r24
 9b0:	02 c0       	rjmp	.+4      	; 0x9b6 <DIO_read+0x28>
 9b2:	66 0f       	add	r22, r22
 9b4:	77 1f       	adc	r23, r23
 9b6:	0a 94       	dec	r0
 9b8:	e2 f7       	brpl	.-8      	; 0x9b2 <DIO_read+0x24>
 9ba:	29 2f       	mov	r18, r25
 9bc:	30 e0       	ldi	r19, 0x00	; 0
 9be:	26 23       	and	r18, r22
 9c0:	37 23       	and	r19, r23
 9c2:	b9 01       	movw	r22, r18
 9c4:	02 c0       	rjmp	.+4      	; 0x9ca <DIO_read+0x3c>
 9c6:	75 95       	asr	r23
 9c8:	67 95       	ror	r22
 9ca:	8a 95       	dec	r24
 9cc:	e2 f7       	brpl	.-8      	; 0x9c6 <DIO_read+0x38>
 9ce:	fa 01       	movw	r30, r20
 9d0:	60 83       	st	Z, r22
		break;
 9d2:	08 95       	ret
		case PORT_B:
		*value = (PINB & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 9d4:	96 b3       	in	r25, 0x16	; 22
 9d6:	21 e0       	ldi	r18, 0x01	; 1
 9d8:	30 e0       	ldi	r19, 0x00	; 0
 9da:	b9 01       	movw	r22, r18
 9dc:	08 2e       	mov	r0, r24
 9de:	02 c0       	rjmp	.+4      	; 0x9e4 <DIO_read+0x56>
 9e0:	66 0f       	add	r22, r22
 9e2:	77 1f       	adc	r23, r23
 9e4:	0a 94       	dec	r0
 9e6:	e2 f7       	brpl	.-8      	; 0x9e0 <DIO_read+0x52>
 9e8:	29 2f       	mov	r18, r25
 9ea:	30 e0       	ldi	r19, 0x00	; 0
 9ec:	26 23       	and	r18, r22
 9ee:	37 23       	and	r19, r23
 9f0:	b9 01       	movw	r22, r18
 9f2:	02 c0       	rjmp	.+4      	; 0x9f8 <DIO_read+0x6a>
 9f4:	75 95       	asr	r23
 9f6:	67 95       	ror	r22
 9f8:	8a 95       	dec	r24
 9fa:	e2 f7       	brpl	.-8      	; 0x9f4 <DIO_read+0x66>
 9fc:	fa 01       	movw	r30, r20
 9fe:	60 83       	st	Z, r22
		break;
 a00:	08 95       	ret
		case PORT_C:
		*value = (PINC & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 a02:	93 b3       	in	r25, 0x13	; 19
 a04:	21 e0       	ldi	r18, 0x01	; 1
 a06:	30 e0       	ldi	r19, 0x00	; 0
 a08:	b9 01       	movw	r22, r18
 a0a:	08 2e       	mov	r0, r24
 a0c:	02 c0       	rjmp	.+4      	; 0xa12 <DIO_read+0x84>
 a0e:	66 0f       	add	r22, r22
 a10:	77 1f       	adc	r23, r23
 a12:	0a 94       	dec	r0
 a14:	e2 f7       	brpl	.-8      	; 0xa0e <DIO_read+0x80>
 a16:	29 2f       	mov	r18, r25
 a18:	30 e0       	ldi	r19, 0x00	; 0
 a1a:	26 23       	and	r18, r22
 a1c:	37 23       	and	r19, r23
 a1e:	b9 01       	movw	r22, r18
 a20:	02 c0       	rjmp	.+4      	; 0xa26 <DIO_read+0x98>
 a22:	75 95       	asr	r23
 a24:	67 95       	ror	r22
 a26:	8a 95       	dec	r24
 a28:	e2 f7       	brpl	.-8      	; 0xa22 <DIO_read+0x94>
 a2a:	fa 01       	movw	r30, r20
 a2c:	60 83       	st	Z, r22
		break;
 a2e:	08 95       	ret
		case PORT_D:
		*value = (PIND & (1<<pinNumber))>>pinNumber; // get state -> read bit 0 or 1
 a30:	90 b3       	in	r25, 0x10	; 16
 a32:	21 e0       	ldi	r18, 0x01	; 1
 a34:	30 e0       	ldi	r19, 0x00	; 0
 a36:	b9 01       	movw	r22, r18
 a38:	08 2e       	mov	r0, r24
 a3a:	02 c0       	rjmp	.+4      	; 0xa40 <DIO_read+0xb2>
 a3c:	66 0f       	add	r22, r22
 a3e:	77 1f       	adc	r23, r23
 a40:	0a 94       	dec	r0
 a42:	e2 f7       	brpl	.-8      	; 0xa3c <DIO_read+0xae>
 a44:	29 2f       	mov	r18, r25
 a46:	30 e0       	ldi	r19, 0x00	; 0
 a48:	26 23       	and	r18, r22
 a4a:	37 23       	and	r19, r23
 a4c:	b9 01       	movw	r22, r18
 a4e:	02 c0       	rjmp	.+4      	; 0xa54 <DIO_read+0xc6>
 a50:	75 95       	asr	r23
 a52:	67 95       	ror	r22
 a54:	8a 95       	dec	r24
 a56:	e2 f7       	brpl	.-8      	; 0xa50 <DIO_read+0xc2>
 a58:	fa 01       	movw	r30, r20
 a5a:	60 83       	st	Z, r22
 a5c:	08 95       	ret

00000a5e <__subsf3>:
 a5e:	50 58       	subi	r21, 0x80	; 128

00000a60 <__addsf3>:
 a60:	bb 27       	eor	r27, r27
 a62:	aa 27       	eor	r26, r26
 a64:	0e 94 47 05 	call	0xa8e	; 0xa8e <__addsf3x>
 a68:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_round>
 a6c:	0e 94 ac 06 	call	0xd58	; 0xd58 <__fp_pscA>
 a70:	38 f0       	brcs	.+14     	; 0xa80 <__addsf3+0x20>
 a72:	0e 94 b3 06 	call	0xd66	; 0xd66 <__fp_pscB>
 a76:	20 f0       	brcs	.+8      	; 0xa80 <__addsf3+0x20>
 a78:	39 f4       	brne	.+14     	; 0xa88 <__addsf3+0x28>
 a7a:	9f 3f       	cpi	r25, 0xFF	; 255
 a7c:	19 f4       	brne	.+6      	; 0xa84 <__addsf3+0x24>
 a7e:	26 f4       	brtc	.+8      	; 0xa88 <__addsf3+0x28>
 a80:	0c 94 a9 06 	jmp	0xd52	; 0xd52 <__fp_nan>
 a84:	0e f4       	brtc	.+2      	; 0xa88 <__addsf3+0x28>
 a86:	e0 95       	com	r30
 a88:	e7 fb       	bst	r30, 7
 a8a:	0c 94 a3 06 	jmp	0xd46	; 0xd46 <__fp_inf>

00000a8e <__addsf3x>:
 a8e:	e9 2f       	mov	r30, r25
 a90:	0e 94 cb 06 	call	0xd96	; 0xd96 <__fp_split3>
 a94:	58 f3       	brcs	.-42     	; 0xa6c <__addsf3+0xc>
 a96:	ba 17       	cp	r27, r26
 a98:	62 07       	cpc	r22, r18
 a9a:	73 07       	cpc	r23, r19
 a9c:	84 07       	cpc	r24, r20
 a9e:	95 07       	cpc	r25, r21
 aa0:	20 f0       	brcs	.+8      	; 0xaaa <__addsf3x+0x1c>
 aa2:	79 f4       	brne	.+30     	; 0xac2 <__addsf3x+0x34>
 aa4:	a6 f5       	brtc	.+104    	; 0xb0e <__addsf3x+0x80>
 aa6:	0c 94 ed 06 	jmp	0xdda	; 0xdda <__fp_zero>
 aaa:	0e f4       	brtc	.+2      	; 0xaae <__addsf3x+0x20>
 aac:	e0 95       	com	r30
 aae:	0b 2e       	mov	r0, r27
 ab0:	ba 2f       	mov	r27, r26
 ab2:	a0 2d       	mov	r26, r0
 ab4:	0b 01       	movw	r0, r22
 ab6:	b9 01       	movw	r22, r18
 ab8:	90 01       	movw	r18, r0
 aba:	0c 01       	movw	r0, r24
 abc:	ca 01       	movw	r24, r20
 abe:	a0 01       	movw	r20, r0
 ac0:	11 24       	eor	r1, r1
 ac2:	ff 27       	eor	r31, r31
 ac4:	59 1b       	sub	r21, r25
 ac6:	99 f0       	breq	.+38     	; 0xaee <__addsf3x+0x60>
 ac8:	59 3f       	cpi	r21, 0xF9	; 249
 aca:	50 f4       	brcc	.+20     	; 0xae0 <__addsf3x+0x52>
 acc:	50 3e       	cpi	r21, 0xE0	; 224
 ace:	68 f1       	brcs	.+90     	; 0xb2a <__addsf3x+0x9c>
 ad0:	1a 16       	cp	r1, r26
 ad2:	f0 40       	sbci	r31, 0x00	; 0
 ad4:	a2 2f       	mov	r26, r18
 ad6:	23 2f       	mov	r18, r19
 ad8:	34 2f       	mov	r19, r20
 ada:	44 27       	eor	r20, r20
 adc:	58 5f       	subi	r21, 0xF8	; 248
 ade:	f3 cf       	rjmp	.-26     	; 0xac6 <__addsf3x+0x38>
 ae0:	46 95       	lsr	r20
 ae2:	37 95       	ror	r19
 ae4:	27 95       	ror	r18
 ae6:	a7 95       	ror	r26
 ae8:	f0 40       	sbci	r31, 0x00	; 0
 aea:	53 95       	inc	r21
 aec:	c9 f7       	brne	.-14     	; 0xae0 <__addsf3x+0x52>
 aee:	7e f4       	brtc	.+30     	; 0xb0e <__addsf3x+0x80>
 af0:	1f 16       	cp	r1, r31
 af2:	ba 0b       	sbc	r27, r26
 af4:	62 0b       	sbc	r22, r18
 af6:	73 0b       	sbc	r23, r19
 af8:	84 0b       	sbc	r24, r20
 afa:	ba f0       	brmi	.+46     	; 0xb2a <__addsf3x+0x9c>
 afc:	91 50       	subi	r25, 0x01	; 1
 afe:	a1 f0       	breq	.+40     	; 0xb28 <__addsf3x+0x9a>
 b00:	ff 0f       	add	r31, r31
 b02:	bb 1f       	adc	r27, r27
 b04:	66 1f       	adc	r22, r22
 b06:	77 1f       	adc	r23, r23
 b08:	88 1f       	adc	r24, r24
 b0a:	c2 f7       	brpl	.-16     	; 0xafc <__addsf3x+0x6e>
 b0c:	0e c0       	rjmp	.+28     	; 0xb2a <__addsf3x+0x9c>
 b0e:	ba 0f       	add	r27, r26
 b10:	62 1f       	adc	r22, r18
 b12:	73 1f       	adc	r23, r19
 b14:	84 1f       	adc	r24, r20
 b16:	48 f4       	brcc	.+18     	; 0xb2a <__addsf3x+0x9c>
 b18:	87 95       	ror	r24
 b1a:	77 95       	ror	r23
 b1c:	67 95       	ror	r22
 b1e:	b7 95       	ror	r27
 b20:	f7 95       	ror	r31
 b22:	9e 3f       	cpi	r25, 0xFE	; 254
 b24:	08 f0       	brcs	.+2      	; 0xb28 <__addsf3x+0x9a>
 b26:	b0 cf       	rjmp	.-160    	; 0xa88 <__addsf3+0x28>
 b28:	93 95       	inc	r25
 b2a:	88 0f       	add	r24, r24
 b2c:	08 f0       	brcs	.+2      	; 0xb30 <__addsf3x+0xa2>
 b2e:	99 27       	eor	r25, r25
 b30:	ee 0f       	add	r30, r30
 b32:	97 95       	ror	r25
 b34:	87 95       	ror	r24
 b36:	08 95       	ret

00000b38 <__cmpsf2>:
 b38:	0e 94 7f 06 	call	0xcfe	; 0xcfe <__fp_cmp>
 b3c:	08 f4       	brcc	.+2      	; 0xb40 <__cmpsf2+0x8>
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	08 95       	ret

00000b42 <__divsf3>:
 b42:	0e 94 b5 05 	call	0xb6a	; 0xb6a <__divsf3x>
 b46:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__fp_round>
 b4a:	0e 94 b3 06 	call	0xd66	; 0xd66 <__fp_pscB>
 b4e:	58 f0       	brcs	.+22     	; 0xb66 <__divsf3+0x24>
 b50:	0e 94 ac 06 	call	0xd58	; 0xd58 <__fp_pscA>
 b54:	40 f0       	brcs	.+16     	; 0xb66 <__divsf3+0x24>
 b56:	29 f4       	brne	.+10     	; 0xb62 <__divsf3+0x20>
 b58:	5f 3f       	cpi	r21, 0xFF	; 255
 b5a:	29 f0       	breq	.+10     	; 0xb66 <__divsf3+0x24>
 b5c:	0c 94 a3 06 	jmp	0xd46	; 0xd46 <__fp_inf>
 b60:	51 11       	cpse	r21, r1
 b62:	0c 94 ee 06 	jmp	0xddc	; 0xddc <__fp_szero>
 b66:	0c 94 a9 06 	jmp	0xd52	; 0xd52 <__fp_nan>

00000b6a <__divsf3x>:
 b6a:	0e 94 cb 06 	call	0xd96	; 0xd96 <__fp_split3>
 b6e:	68 f3       	brcs	.-38     	; 0xb4a <__divsf3+0x8>

00000b70 <__divsf3_pse>:
 b70:	99 23       	and	r25, r25
 b72:	b1 f3       	breq	.-20     	; 0xb60 <__divsf3+0x1e>
 b74:	55 23       	and	r21, r21
 b76:	91 f3       	breq	.-28     	; 0xb5c <__divsf3+0x1a>
 b78:	95 1b       	sub	r25, r21
 b7a:	55 0b       	sbc	r21, r21
 b7c:	bb 27       	eor	r27, r27
 b7e:	aa 27       	eor	r26, r26
 b80:	62 17       	cp	r22, r18
 b82:	73 07       	cpc	r23, r19
 b84:	84 07       	cpc	r24, r20
 b86:	38 f0       	brcs	.+14     	; 0xb96 <__divsf3_pse+0x26>
 b88:	9f 5f       	subi	r25, 0xFF	; 255
 b8a:	5f 4f       	sbci	r21, 0xFF	; 255
 b8c:	22 0f       	add	r18, r18
 b8e:	33 1f       	adc	r19, r19
 b90:	44 1f       	adc	r20, r20
 b92:	aa 1f       	adc	r26, r26
 b94:	a9 f3       	breq	.-22     	; 0xb80 <__divsf3_pse+0x10>
 b96:	35 d0       	rcall	.+106    	; 0xc02 <__divsf3_pse+0x92>
 b98:	0e 2e       	mov	r0, r30
 b9a:	3a f0       	brmi	.+14     	; 0xbaa <__divsf3_pse+0x3a>
 b9c:	e0 e8       	ldi	r30, 0x80	; 128
 b9e:	32 d0       	rcall	.+100    	; 0xc04 <__divsf3_pse+0x94>
 ba0:	91 50       	subi	r25, 0x01	; 1
 ba2:	50 40       	sbci	r21, 0x00	; 0
 ba4:	e6 95       	lsr	r30
 ba6:	00 1c       	adc	r0, r0
 ba8:	ca f7       	brpl	.-14     	; 0xb9c <__divsf3_pse+0x2c>
 baa:	2b d0       	rcall	.+86     	; 0xc02 <__divsf3_pse+0x92>
 bac:	fe 2f       	mov	r31, r30
 bae:	29 d0       	rcall	.+82     	; 0xc02 <__divsf3_pse+0x92>
 bb0:	66 0f       	add	r22, r22
 bb2:	77 1f       	adc	r23, r23
 bb4:	88 1f       	adc	r24, r24
 bb6:	bb 1f       	adc	r27, r27
 bb8:	26 17       	cp	r18, r22
 bba:	37 07       	cpc	r19, r23
 bbc:	48 07       	cpc	r20, r24
 bbe:	ab 07       	cpc	r26, r27
 bc0:	b0 e8       	ldi	r27, 0x80	; 128
 bc2:	09 f0       	breq	.+2      	; 0xbc6 <__divsf3_pse+0x56>
 bc4:	bb 0b       	sbc	r27, r27
 bc6:	80 2d       	mov	r24, r0
 bc8:	bf 01       	movw	r22, r30
 bca:	ff 27       	eor	r31, r31
 bcc:	93 58       	subi	r25, 0x83	; 131
 bce:	5f 4f       	sbci	r21, 0xFF	; 255
 bd0:	3a f0       	brmi	.+14     	; 0xbe0 <__divsf3_pse+0x70>
 bd2:	9e 3f       	cpi	r25, 0xFE	; 254
 bd4:	51 05       	cpc	r21, r1
 bd6:	78 f0       	brcs	.+30     	; 0xbf6 <__divsf3_pse+0x86>
 bd8:	0c 94 a3 06 	jmp	0xd46	; 0xd46 <__fp_inf>
 bdc:	0c 94 ee 06 	jmp	0xddc	; 0xddc <__fp_szero>
 be0:	5f 3f       	cpi	r21, 0xFF	; 255
 be2:	e4 f3       	brlt	.-8      	; 0xbdc <__divsf3_pse+0x6c>
 be4:	98 3e       	cpi	r25, 0xE8	; 232
 be6:	d4 f3       	brlt	.-12     	; 0xbdc <__divsf3_pse+0x6c>
 be8:	86 95       	lsr	r24
 bea:	77 95       	ror	r23
 bec:	67 95       	ror	r22
 bee:	b7 95       	ror	r27
 bf0:	f7 95       	ror	r31
 bf2:	9f 5f       	subi	r25, 0xFF	; 255
 bf4:	c9 f7       	brne	.-14     	; 0xbe8 <__divsf3_pse+0x78>
 bf6:	88 0f       	add	r24, r24
 bf8:	91 1d       	adc	r25, r1
 bfa:	96 95       	lsr	r25
 bfc:	87 95       	ror	r24
 bfe:	97 f9       	bld	r25, 7
 c00:	08 95       	ret
 c02:	e1 e0       	ldi	r30, 0x01	; 1
 c04:	66 0f       	add	r22, r22
 c06:	77 1f       	adc	r23, r23
 c08:	88 1f       	adc	r24, r24
 c0a:	bb 1f       	adc	r27, r27
 c0c:	62 17       	cp	r22, r18
 c0e:	73 07       	cpc	r23, r19
 c10:	84 07       	cpc	r24, r20
 c12:	ba 07       	cpc	r27, r26
 c14:	20 f0       	brcs	.+8      	; 0xc1e <__divsf3_pse+0xae>
 c16:	62 1b       	sub	r22, r18
 c18:	73 0b       	sbc	r23, r19
 c1a:	84 0b       	sbc	r24, r20
 c1c:	ba 0b       	sbc	r27, r26
 c1e:	ee 1f       	adc	r30, r30
 c20:	88 f7       	brcc	.-30     	; 0xc04 <__divsf3_pse+0x94>
 c22:	e0 95       	com	r30
 c24:	08 95       	ret

00000c26 <__fixunssfsi>:
 c26:	0e 94 d3 06 	call	0xda6	; 0xda6 <__fp_splitA>
 c2a:	88 f0       	brcs	.+34     	; 0xc4e <__fixunssfsi+0x28>
 c2c:	9f 57       	subi	r25, 0x7F	; 127
 c2e:	98 f0       	brcs	.+38     	; 0xc56 <__fixunssfsi+0x30>
 c30:	b9 2f       	mov	r27, r25
 c32:	99 27       	eor	r25, r25
 c34:	b7 51       	subi	r27, 0x17	; 23
 c36:	b0 f0       	brcs	.+44     	; 0xc64 <__fixunssfsi+0x3e>
 c38:	e1 f0       	breq	.+56     	; 0xc72 <__fixunssfsi+0x4c>
 c3a:	66 0f       	add	r22, r22
 c3c:	77 1f       	adc	r23, r23
 c3e:	88 1f       	adc	r24, r24
 c40:	99 1f       	adc	r25, r25
 c42:	1a f0       	brmi	.+6      	; 0xc4a <__fixunssfsi+0x24>
 c44:	ba 95       	dec	r27
 c46:	c9 f7       	brne	.-14     	; 0xc3a <__fixunssfsi+0x14>
 c48:	14 c0       	rjmp	.+40     	; 0xc72 <__fixunssfsi+0x4c>
 c4a:	b1 30       	cpi	r27, 0x01	; 1
 c4c:	91 f0       	breq	.+36     	; 0xc72 <__fixunssfsi+0x4c>
 c4e:	0e 94 ed 06 	call	0xdda	; 0xdda <__fp_zero>
 c52:	b1 e0       	ldi	r27, 0x01	; 1
 c54:	08 95       	ret
 c56:	0c 94 ed 06 	jmp	0xdda	; 0xdda <__fp_zero>
 c5a:	67 2f       	mov	r22, r23
 c5c:	78 2f       	mov	r23, r24
 c5e:	88 27       	eor	r24, r24
 c60:	b8 5f       	subi	r27, 0xF8	; 248
 c62:	39 f0       	breq	.+14     	; 0xc72 <__fixunssfsi+0x4c>
 c64:	b9 3f       	cpi	r27, 0xF9	; 249
 c66:	cc f3       	brlt	.-14     	; 0xc5a <__fixunssfsi+0x34>
 c68:	86 95       	lsr	r24
 c6a:	77 95       	ror	r23
 c6c:	67 95       	ror	r22
 c6e:	b3 95       	inc	r27
 c70:	d9 f7       	brne	.-10     	; 0xc68 <__fixunssfsi+0x42>
 c72:	3e f4       	brtc	.+14     	; 0xc82 <__fixunssfsi+0x5c>
 c74:	90 95       	com	r25
 c76:	80 95       	com	r24
 c78:	70 95       	com	r23
 c7a:	61 95       	neg	r22
 c7c:	7f 4f       	sbci	r23, 0xFF	; 255
 c7e:	8f 4f       	sbci	r24, 0xFF	; 255
 c80:	9f 4f       	sbci	r25, 0xFF	; 255
 c82:	08 95       	ret

00000c84 <__floatunsisf>:
 c84:	e8 94       	clt
 c86:	09 c0       	rjmp	.+18     	; 0xc9a <__floatsisf+0x12>

00000c88 <__floatsisf>:
 c88:	97 fb       	bst	r25, 7
 c8a:	3e f4       	brtc	.+14     	; 0xc9a <__floatsisf+0x12>
 c8c:	90 95       	com	r25
 c8e:	80 95       	com	r24
 c90:	70 95       	com	r23
 c92:	61 95       	neg	r22
 c94:	7f 4f       	sbci	r23, 0xFF	; 255
 c96:	8f 4f       	sbci	r24, 0xFF	; 255
 c98:	9f 4f       	sbci	r25, 0xFF	; 255
 c9a:	99 23       	and	r25, r25
 c9c:	a9 f0       	breq	.+42     	; 0xcc8 <__floatsisf+0x40>
 c9e:	f9 2f       	mov	r31, r25
 ca0:	96 e9       	ldi	r25, 0x96	; 150
 ca2:	bb 27       	eor	r27, r27
 ca4:	93 95       	inc	r25
 ca6:	f6 95       	lsr	r31
 ca8:	87 95       	ror	r24
 caa:	77 95       	ror	r23
 cac:	67 95       	ror	r22
 cae:	b7 95       	ror	r27
 cb0:	f1 11       	cpse	r31, r1
 cb2:	f8 cf       	rjmp	.-16     	; 0xca4 <__floatsisf+0x1c>
 cb4:	fa f4       	brpl	.+62     	; 0xcf4 <__floatsisf+0x6c>
 cb6:	bb 0f       	add	r27, r27
 cb8:	11 f4       	brne	.+4      	; 0xcbe <__floatsisf+0x36>
 cba:	60 ff       	sbrs	r22, 0
 cbc:	1b c0       	rjmp	.+54     	; 0xcf4 <__floatsisf+0x6c>
 cbe:	6f 5f       	subi	r22, 0xFF	; 255
 cc0:	7f 4f       	sbci	r23, 0xFF	; 255
 cc2:	8f 4f       	sbci	r24, 0xFF	; 255
 cc4:	9f 4f       	sbci	r25, 0xFF	; 255
 cc6:	16 c0       	rjmp	.+44     	; 0xcf4 <__floatsisf+0x6c>
 cc8:	88 23       	and	r24, r24
 cca:	11 f0       	breq	.+4      	; 0xcd0 <__floatsisf+0x48>
 ccc:	96 e9       	ldi	r25, 0x96	; 150
 cce:	11 c0       	rjmp	.+34     	; 0xcf2 <__floatsisf+0x6a>
 cd0:	77 23       	and	r23, r23
 cd2:	21 f0       	breq	.+8      	; 0xcdc <__floatsisf+0x54>
 cd4:	9e e8       	ldi	r25, 0x8E	; 142
 cd6:	87 2f       	mov	r24, r23
 cd8:	76 2f       	mov	r23, r22
 cda:	05 c0       	rjmp	.+10     	; 0xce6 <__floatsisf+0x5e>
 cdc:	66 23       	and	r22, r22
 cde:	71 f0       	breq	.+28     	; 0xcfc <__floatsisf+0x74>
 ce0:	96 e8       	ldi	r25, 0x86	; 134
 ce2:	86 2f       	mov	r24, r22
 ce4:	70 e0       	ldi	r23, 0x00	; 0
 ce6:	60 e0       	ldi	r22, 0x00	; 0
 ce8:	2a f0       	brmi	.+10     	; 0xcf4 <__floatsisf+0x6c>
 cea:	9a 95       	dec	r25
 cec:	66 0f       	add	r22, r22
 cee:	77 1f       	adc	r23, r23
 cf0:	88 1f       	adc	r24, r24
 cf2:	da f7       	brpl	.-10     	; 0xcea <__floatsisf+0x62>
 cf4:	88 0f       	add	r24, r24
 cf6:	96 95       	lsr	r25
 cf8:	87 95       	ror	r24
 cfa:	97 f9       	bld	r25, 7
 cfc:	08 95       	ret

00000cfe <__fp_cmp>:
 cfe:	99 0f       	add	r25, r25
 d00:	00 08       	sbc	r0, r0
 d02:	55 0f       	add	r21, r21
 d04:	aa 0b       	sbc	r26, r26
 d06:	e0 e8       	ldi	r30, 0x80	; 128
 d08:	fe ef       	ldi	r31, 0xFE	; 254
 d0a:	16 16       	cp	r1, r22
 d0c:	17 06       	cpc	r1, r23
 d0e:	e8 07       	cpc	r30, r24
 d10:	f9 07       	cpc	r31, r25
 d12:	c0 f0       	brcs	.+48     	; 0xd44 <__fp_cmp+0x46>
 d14:	12 16       	cp	r1, r18
 d16:	13 06       	cpc	r1, r19
 d18:	e4 07       	cpc	r30, r20
 d1a:	f5 07       	cpc	r31, r21
 d1c:	98 f0       	brcs	.+38     	; 0xd44 <__fp_cmp+0x46>
 d1e:	62 1b       	sub	r22, r18
 d20:	73 0b       	sbc	r23, r19
 d22:	84 0b       	sbc	r24, r20
 d24:	95 0b       	sbc	r25, r21
 d26:	39 f4       	brne	.+14     	; 0xd36 <__fp_cmp+0x38>
 d28:	0a 26       	eor	r0, r26
 d2a:	61 f0       	breq	.+24     	; 0xd44 <__fp_cmp+0x46>
 d2c:	23 2b       	or	r18, r19
 d2e:	24 2b       	or	r18, r20
 d30:	25 2b       	or	r18, r21
 d32:	21 f4       	brne	.+8      	; 0xd3c <__fp_cmp+0x3e>
 d34:	08 95       	ret
 d36:	0a 26       	eor	r0, r26
 d38:	09 f4       	brne	.+2      	; 0xd3c <__fp_cmp+0x3e>
 d3a:	a1 40       	sbci	r26, 0x01	; 1
 d3c:	a6 95       	lsr	r26
 d3e:	8f ef       	ldi	r24, 0xFF	; 255
 d40:	81 1d       	adc	r24, r1
 d42:	81 1d       	adc	r24, r1
 d44:	08 95       	ret

00000d46 <__fp_inf>:
 d46:	97 f9       	bld	r25, 7
 d48:	9f 67       	ori	r25, 0x7F	; 127
 d4a:	80 e8       	ldi	r24, 0x80	; 128
 d4c:	70 e0       	ldi	r23, 0x00	; 0
 d4e:	60 e0       	ldi	r22, 0x00	; 0
 d50:	08 95       	ret

00000d52 <__fp_nan>:
 d52:	9f ef       	ldi	r25, 0xFF	; 255
 d54:	80 ec       	ldi	r24, 0xC0	; 192
 d56:	08 95       	ret

00000d58 <__fp_pscA>:
 d58:	00 24       	eor	r0, r0
 d5a:	0a 94       	dec	r0
 d5c:	16 16       	cp	r1, r22
 d5e:	17 06       	cpc	r1, r23
 d60:	18 06       	cpc	r1, r24
 d62:	09 06       	cpc	r0, r25
 d64:	08 95       	ret

00000d66 <__fp_pscB>:
 d66:	00 24       	eor	r0, r0
 d68:	0a 94       	dec	r0
 d6a:	12 16       	cp	r1, r18
 d6c:	13 06       	cpc	r1, r19
 d6e:	14 06       	cpc	r1, r20
 d70:	05 06       	cpc	r0, r21
 d72:	08 95       	ret

00000d74 <__fp_round>:
 d74:	09 2e       	mov	r0, r25
 d76:	03 94       	inc	r0
 d78:	00 0c       	add	r0, r0
 d7a:	11 f4       	brne	.+4      	; 0xd80 <__fp_round+0xc>
 d7c:	88 23       	and	r24, r24
 d7e:	52 f0       	brmi	.+20     	; 0xd94 <__fp_round+0x20>
 d80:	bb 0f       	add	r27, r27
 d82:	40 f4       	brcc	.+16     	; 0xd94 <__fp_round+0x20>
 d84:	bf 2b       	or	r27, r31
 d86:	11 f4       	brne	.+4      	; 0xd8c <__fp_round+0x18>
 d88:	60 ff       	sbrs	r22, 0
 d8a:	04 c0       	rjmp	.+8      	; 0xd94 <__fp_round+0x20>
 d8c:	6f 5f       	subi	r22, 0xFF	; 255
 d8e:	7f 4f       	sbci	r23, 0xFF	; 255
 d90:	8f 4f       	sbci	r24, 0xFF	; 255
 d92:	9f 4f       	sbci	r25, 0xFF	; 255
 d94:	08 95       	ret

00000d96 <__fp_split3>:
 d96:	57 fd       	sbrc	r21, 7
 d98:	90 58       	subi	r25, 0x80	; 128
 d9a:	44 0f       	add	r20, r20
 d9c:	55 1f       	adc	r21, r21
 d9e:	59 f0       	breq	.+22     	; 0xdb6 <__fp_splitA+0x10>
 da0:	5f 3f       	cpi	r21, 0xFF	; 255
 da2:	71 f0       	breq	.+28     	; 0xdc0 <__fp_splitA+0x1a>
 da4:	47 95       	ror	r20

00000da6 <__fp_splitA>:
 da6:	88 0f       	add	r24, r24
 da8:	97 fb       	bst	r25, 7
 daa:	99 1f       	adc	r25, r25
 dac:	61 f0       	breq	.+24     	; 0xdc6 <__fp_splitA+0x20>
 dae:	9f 3f       	cpi	r25, 0xFF	; 255
 db0:	79 f0       	breq	.+30     	; 0xdd0 <__fp_splitA+0x2a>
 db2:	87 95       	ror	r24
 db4:	08 95       	ret
 db6:	12 16       	cp	r1, r18
 db8:	13 06       	cpc	r1, r19
 dba:	14 06       	cpc	r1, r20
 dbc:	55 1f       	adc	r21, r21
 dbe:	f2 cf       	rjmp	.-28     	; 0xda4 <__fp_split3+0xe>
 dc0:	46 95       	lsr	r20
 dc2:	f1 df       	rcall	.-30     	; 0xda6 <__fp_splitA>
 dc4:	08 c0       	rjmp	.+16     	; 0xdd6 <__fp_splitA+0x30>
 dc6:	16 16       	cp	r1, r22
 dc8:	17 06       	cpc	r1, r23
 dca:	18 06       	cpc	r1, r24
 dcc:	99 1f       	adc	r25, r25
 dce:	f1 cf       	rjmp	.-30     	; 0xdb2 <__fp_splitA+0xc>
 dd0:	86 95       	lsr	r24
 dd2:	71 05       	cpc	r23, r1
 dd4:	61 05       	cpc	r22, r1
 dd6:	08 94       	sec
 dd8:	08 95       	ret

00000dda <__fp_zero>:
 dda:	e8 94       	clt

00000ddc <__fp_szero>:
 ddc:	bb 27       	eor	r27, r27
 dde:	66 27       	eor	r22, r22
 de0:	77 27       	eor	r23, r23
 de2:	cb 01       	movw	r24, r22
 de4:	97 f9       	bld	r25, 7
 de6:	08 95       	ret

00000de8 <_exit>:
 de8:	f8 94       	cli

00000dea <__stop_program>:
 dea:	ff cf       	rjmp	.-2      	; 0xdea <__stop_program>
